---
title: Comparison with XState
description: Bundle size and performance comparison between effstate and XState
---

## Bundle Size

effstate is significantly smaller than XState, making it ideal for bundle-conscious applications.

| Library | Minified | Minified + Gzipped |
|---------|----------|-------------------|
| **effstate** | **~14 kB** | **~3.9 kB** |
| XState | 45.3 kB | 13.7 kB |

effstate is **~3.5x smaller** than XState (gzipped).

:::note
effstate requires `effect` as a peer dependency. The Effect library adds to your bundle, but if you're already using Effect in your application, effstate adds minimal overhead.
:::

## Performance Benchmarks

We benchmark both libraries with equivalent state machine implementations to ensure fair comparison.

### Machine Creation

Creating a new state machine definition.

| Library | ops/sec | Mean (μs) |
|---------|---------|-----------|
| **effstate** | **14,316,058** | **0.070** |
| XState | 340,392 | 2.938 |

effstate is **~42x faster** at machine creation.

### Actor Lifecycle

Creating, starting, and stopping an actor.

| Library | ops/sec | Mean (μs) |
|---------|---------|-----------|
| effstate | 55,228 | 18.107 |
| **XState** | **335,239** | **2.983** |

XState is ~6x faster at actor lifecycle. This is the cost of effstate's Effect-first architecture - actor creation goes through Effect's runtime for proper dependency injection and scope management. However, this is typically a one-time cost per actor.

### Event Sending (1000 events)

Sending 1000 events to a running actor.

| Library | ops/sec | Mean (μs) |
|---------|---------|-----------|
| **effstate** | **14,877** | **67.2** |
| XState | 621 | 1609.3 |

effstate is **~24x faster** at event processing.

### With Subscribers (5 subscribers, 100 events)

Processing events with multiple subscribers attached.

| Library | ops/sec | Mean (μs) |
|---------|---------|-----------|
| **effstate** | **42,998** | **23.3** |
| XState | 4,769 | 209.7 |

effstate is **~9x faster** with subscribers.

### Realistic App Lifecycle

Complete workflow simulating real app usage: create actor → subscribe (like React component) → 50 user interactions → unsubscribe → stop.

| Library | ops/sec | Mean (μs) |
|---------|---------|-----------|
| **effstate** | **51,633** | **19.4** |
| XState | 11,444 | 87.4 |

effstate is **~4.5x faster** for realistic app lifecycles.

## Summary

| Benchmark | Winner | Factor |
|-----------|--------|--------|
| Machine Creation | effstate | 42x faster |
| Actor Lifecycle | XState | 6x faster |
| Event Sending | effstate | 24x faster |
| With Subscribers | effstate | 9x faster |
| Realistic Lifecycle | effstate | 4.5x faster |

**Final Score: effstate 4 - 1 XState**

### Why the Difference?

**XState has additional overhead from:**
- DevTools/inspection support (always-on)
- Actor system relay for distributed event routing
- Full Observable protocol (next/error/complete)

**effstate is optimized for:**
- Minimal runtime overhead for event processing
- Simple callbacks with error isolation
- Effect ecosystem integration
- Hierarchical parent/child actor communication

### What Matters Most?

Actor creation happens once, but events are sent many times. In real applications:
- You create an actor when the app/component mounts
- You send dozens or hundreds of events during the actor's lifetime
- effstate's 24x faster event processing dominates the overall performance

## Running the Benchmarks

You can run the benchmarks yourself:

```bash
git clone https://github.com/handfish/effstate
cd effstate
pnpm install
pnpm --filter effstate bench
```

The benchmark code is in `packages/core/bench/machine.bench.ts`.
